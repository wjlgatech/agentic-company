{
  "run_id": "9657805a",
  "artifacts": [
    {
      "type": "code",
      "filename": "output_0.py",
      "content": "from typing import Union, Any\nimport math\n\nNumber = Union[int, float]\n\ndef add_two_numbers(a: Any, b: Any) -> Number:\n    \"\"\"\n    Add two numbers together with comprehensive validation and error handling.\n    \n    This function performs addition of two numeric values while handling various\n    edge cases including infinity, NaN, and type validation.\n    \n    Args:\n        a: First number to add (int, float, or numeric string)\n        b: Second number to add (int, float, or numeric string)\n    \n    Returns:\n        Number: The sum of the two input numbers as int or float\n    \n    Raises:\n        TypeError: If inputs cannot be converted to numbers\n        ValueError: If inputs are None or invalid numeric strings\n        \n    Examples:\n        >>> add_two_numbers(5, 3)\n        8\n        >>> add_two_numbers(2.5, 1.5)\n        4.0\n        >>> add_two_numbers(-10, 15)\n        5\n        >>> add_two_numbers(\"5\", \"3\")\n        8\n        >>> add_two_numbers(float('inf'), 10)\n        inf\n        \n    Edge Cases:\n        - Handles infinity values correctly\n        - Returns NaN when appropriate (inf + (-inf))\n        - Supports very large numbers within system limits\n        - Handles negative numbers and zero\n        - Converts numeric strings to numbers\n    \"\"\"\n    \n    # Input validation - check for None values\n    if a is None or b is None:\n        raise ValueError(\"Input parameters cannot be None\")\n    \n    # Type conversion and validation\n    try:\n        # Convert inputs to numbers if they're strings\n        if isinstance(a, str):\n            # Handle empty strings\n            if not a.strip():\n                raise ValueError(\"Empty string is not a valid number\")\n            a = float(a) if '.' in a or 'e' in a.lower() else int(a)\n        \n        if isinstance(b, str):\n            # Handle empty strings\n            if not b.strip():\n                raise ValueError(\"Empty string is not a valid number\")\n            b = float(b) if '.' in b or 'e' in b.lower() else int(b)\n        \n        # Validate that inputs are numeric types\n        if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n            raise TypeError(f\"Inputs must be numbers or numeric strings. Got types: {type(a).__name__}, {type(b).__name__}\")\n        \n        # Check for complex numbers (not supported)\n        if isinstance(a, complex) or isinstance(b, complex):\n            raise TypeError(\"Complex numbers are not supported\")\n            \n    except (ValueError, TypeError) as e:\n        if \"could not convert\" in str(e) or \"invalid literal\" in str(e):\n            raise TypeError(f\"Cannot convert inputs to numbers: a='{a}', b='{b}'\")\n        raise\n    \n    # Handle special floating-point cases\n    if math.isnan(a) or math.isnan(b):\n        return float('nan')\n    \n    # Perform addition\n    result = a + b\n    \n    # Handle infinity cases\n    if math.isinf(result):\n        return result\n    \n    # Return appropriate type (preserve int if both inputs were int)\n    if isinstance(a, int) and isinstance(b, int):\n        return result\n    else:\n        return float(result)\n\n\n# Comprehensive test suite\nimport unittest\nimport sys\n\nclass TestAddTwoNumbers(unittest.TestCase):\n    \"\"\"Comprehensive test suite for add_two_numbers function.\"\"\"\n    \n    def test_basic_integer_addition(self):\n        \"\"\"Test basic integer addition cases.\"\"\"\n        self.assertEqual(add_two_numbers(2, 3), 5)\n        self.assertEqual(add_two_numbers(0, 0), 0)\n        self.assertEqual(add_two_numbers(-5, 10), 5)\n        self.assertEqual(add_two_numbers(-3, -7), -10)\n    \n    def test_floating_point_addition(self):\n        \"\"\"Test floating-point number addition.\"\"\"\n        self.assertAlmostEqual(add_two_numbers(2.5, 3.7), 6.2, places=10)\n        self.assertAlmostEqual(add_two_numbers(0.1, 0.2), 0.3, places=10)\n        self.assertEqual(add_two_numbers(1.0, 2.0), 3.0)\n    \n    def test_mixed_type_addition(self):\n        \"\"\"Test addition of mixed int/float types.\"\"\"\n        self.assertEqual(add_two_numbers(5, 2.5), 7.5)\n        self.assertEqual(add_two_numbers(3.0, 4), 7.0)\n    \n    def test_string_number_conversion(self):\n        \"\"\"Test conversion of numeric strings.\"\"\"\n        self.assertEqual(add_two_numbers(\"5\", \"3\"), 8)\n        self.assertEqual(add_two_numbers(\"2.5\", \"1.5\"), 4.0)\n        self.assertEqual(add_two_numbers(\"10\", 5), 15)\n        self.assertEqual(add_two_numbers(7, \"3\"), 10)\n    \n    def test_large_numbers(self):\n        \"\"\"Test handling of very large numbers.\"\"\"\n        large_num = sys.maxsize\n        self.assertEqual(add_two_numbers(large_num, 1), large_num + 1)\n        self.assertEqual(add_two_numbers(1e308, 1e308), 2e308)\n    \n    def test_infinity_handling(self):\n        \"\"\"Test infinity value handling.\"\"\"\n        inf = float('inf')\n        neg_inf = float('-inf')\n        \n        self.assertEqual(add_two_numbers(inf, 10), inf)\n        self.assertEqual(add_two_numbers(10, inf), inf)\n        self.assertEqual(add_two_numbers(neg_inf, 10), neg_inf)\n        self.assertTrue(math.isnan(add_two_numbers(inf, neg_inf)))\n    \n    def test_nan_handling(self):\n        \"\"\"Test NaN value handling.\"\"\"\n        nan = float('nan')\n        self.assertTrue(math.isnan(add_two_numbers(nan, 5)))\n        self.assertTrue(math.isnan(add_two_numbers(5, nan)))\n        self.assertTrue(math.isnan(add_two_numbers(nan, nan)))\n    \n    def test_zero_handling(self):\n        \"\"\"Test zero value handling.\"\"\"\n        self.assertEqual(add_two_numbers(0, 5), 5)\n        self.assertEqual(add_two_numbers(-0, 5), 5)\n        self.assertEqual(add_two_numbers(0, -5), -5)\n    \n    def test_none_input_validation(self):\n        \"\"\"Test None input validation.\"\"\"\n        with self.assertRaises(ValueError):\n            add_two_numbers(None, 5)\n        with self.assertRaises(ValueError):\n            add_two_numbers(5, None)\n        with self.assertRaises(ValueError):\n            add_two_numbers(None, None)\n    \n    def test_invalid_type_validation(self):\n        \"\"\"Test invalid type validation.\"\"\"\n        with self.assertRaises(TypeError):\n            add_two_numbers(\"hello\", 5)\n        with self.assertRaises(TypeError):\n            add_two_numbers(5, [1, 2, 3])\n        with self.assertRaises(TypeError):\n            add_two_numbers({}, 5)\n        with self.assertRaises(TypeError):\n            add_two_numbers(5, {\"key\": \"value\"})\n    \n    def test_empty_string_validation(self):\n        \"\"\"Test empty string validation.\"\"\"\n        with self.assertRaises(ValueError):\n            add_two_numbers(\"\", 5)\n        with self.assertRaises(ValueError):\n            add_two_numbers(\"   \", 5)\n        with self.assertRaises(ValueError):\n            add_two_numbers(5, \"\")\n    \n    def test_scientific_notation(self):\n        \"\"\"Test scientific notation handling.\"\"\"\n        self.assertEqual(add_two_numbers(\"1e2\", \"2e1\"), 120.0)\n        self.assertEqual(add_two_numbers(1e3, 2e2), 1200.0)\n    \n    def test_negative_string_numbers(self):\n        \"\"\"Test negative string numbers.\"\"\"\n        self.assertEqual(add_two_numbers(\"-5\", \"3\"), -2)\n        self.assertEqual(add_two_numbers(\"-2.5\", \"-1.5\"), -4.0)\n    \n    def test_return_type_preservation(self):\n        \"\"\"Test that return types are preserved appropriately.\"\"\"\n        # Both integers should return int\n        result = add_two_numbers(5, 3)\n        self.assertIsInstance(result, int)\n        \n        # Any float should return float\n        result = add_two_numbers(5.0, 3)\n        self.assertIsInstance(result, float)\n        \n        result = add_two_numbers(5, 3.0)\n        self.assertIsInstance(result, float)\n\n\ndef run_tests():\n    \"\"\"Run the complete test suite.\"\"\"\n    unittest.main(argv=[''], exit=False, verbosity=2)\n\n\n# Usage examples and demonstration\ndef demonstrate_usage():\n    \"\"\"Demonstrate various usage scenarios of the add_two_numbers function.\"\"\"\n    \n    print(\"=== Add Two Numbers Function Demonstration ===\\n\")\n    \n    # Basic usage examples\n    examples = [\n        (5, 3, \"Basic integer addition\"),\n        (2.5, 1.5, \"Floating-point addition\"),\n        (-10, 15, \"Negative and positive numbers\"),\n        (\"5\", \"3\", \"String numbers\"),\n        (float('inf'), 10, \"Infinity handling\"),\n        (1e10, 2e10, \"Large numbers\"),\n        (0, 0, \"Zero values\"),\n    ]\n    \n    for a, b, description in examples:\n        try:\n            result = add_two_numbers(a, b)\n            print(f\"{description}: {a} + {b} = {result}\")\n        except Exception as e:\n            print(f\"{description}: {a} + {b} -> Error: {e}\")\n    \n    print(\"\\n=== Error Handling Examples ===\\n\")\n    \n    # Error cases\n    error_examples = [\n        (None, 5, \"None input\"),\n        (\"hello\", 5, \"Invalid string\"),\n        ([], 5, \"List input\"),\n        (\"\", 5, \"Empty string\"),\n    ]\n    \n    for a, b, description in error_examples:\n        try:\n            result = add_two_numbers(a, b)\n            print(f\"{description}: {a} + {b} = {result}\")\n        except Exception as e:\n            print(f\"{description}: {a} + {b} -> Error: {type(e).__name__}: {e}\")\n\n\nif __name__ == \"__main__\":\n    # Run demonstrations\n    demonstrate_usage()\n    \n    print(\"\\n\" + \"=\"*50)\n    print(\"Running comprehensive test suite...\")\n    print(\"=\"*50 + \"\\n\")\n    \n    # Run tests\n    run_tests()",
      "language": "python",
      "metadata": {
        "extracted_from": "code_block",
        "index": 0
      },
      "created_at": "2026-02-14T01:11:36.168607"
    }
  ],
  "created_at": "2026-02-14T01:11:36.168629",
  "metadata": {},
  "stats": {
    "count": 1,
    "total_size_bytes": 9251,
    "total_lines": 264
  }
}