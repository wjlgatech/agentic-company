{
  "run_id": "d0b53bc1",
  "artifacts": [
    {
      "type": "code",
      "filename": "output_0.py",
      "content": "\"\"\"\nSimple Todo List Application\n\nA command-line todo list manager that allows users to add, view, and delete todo items.\nAll data is stored in memory during the application session.\n\"\"\"\n\nimport uuid\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Tuple\n\n\nclass TodoItem:\n    \"\"\"Represents a single todo item with ID, description, and timestamp.\"\"\"\n    \n    def __init__(self, description: str) -> None:\n        \"\"\"\n        Initialize a new todo item.\n        \n        Args:\n            description: The todo item description\n        \"\"\"\n        self.id: str = str(uuid.uuid4())[:8]  # Short UUID for readability\n        self.description: str = description.strip()\n        self.created_at: datetime = datetime.now()\n    \n    def to_dict(self) -> Dict[str, str]:\n        \"\"\"Convert todo item to dictionary format.\"\"\"\n        return {\n            'id': self.id,\n            'description': self.description,\n            'created_at': self.created_at.strftime('%Y-%m-%d %H:%M:%S')\n        }\n    \n    def __str__(self) -> str:\n        \"\"\"String representation of todo item.\"\"\"\n        return f\"[{self.id}] {self.description} (Created: {self.created_at.strftime('%Y-%m-%d %H:%M:%S')})\"\n\n\nclass TodoManager:\n    \"\"\"Manages todo items with CRUD operations.\"\"\"\n    \n    def __init__(self) -> None:\n        \"\"\"Initialize empty todo list.\"\"\"\n        self._todos: Dict[str, TodoItem] = {}\n    \n    def add_todo(self, description: str) -> Tuple[bool, str]:\n        \"\"\"\n        Add a new todo item to the list.\n        \n        Args:\n            description: The todo item description\n            \n        Returns:\n            Tuple of (success: bool, message: str)\n        \"\"\"\n        if not description or not description.strip():\n            return False, \"Error: Todo description cannot be empty\"\n        \n        if len(description.strip()) > 200:\n            return False, \"Error: Todo description must be 200 characters or less\"\n        \n        todo_item = TodoItem(description)\n        self._todos[todo_item.id] = todo_item\n        \n        return True, f\"Todo added successfully with ID: {todo_item.id}\"\n    \n    def list_todos(self) -> Tuple[bool, str]:\n        \"\"\"\n        List all todo items.\n        \n        Returns:\n            Tuple of (success: bool, formatted_list: str)\n        \"\"\"\n        if not self._todos:\n            return True, \"No todo items found. Your list is empty!\"\n        \n        # Sort by creation timestamp\n        sorted_todos = sorted(self._todos.values(), key=lambda x: x.created_at)\n        \n        result = f\"\\n--- Todo List ({len(sorted_todos)} items) ---\\n\"\n        for i, todo in enumerate(sorted_todos, 1):\n            result += f\"{i}. {todo}\\n\"\n        \n        return True, result\n    \n    def delete_todo(self, todo_id: str) -> Tuple[bool, str]:\n        \"\"\"\n        Delete a todo item by ID.\n        \n        Args:\n            todo_id: The ID of the todo item to delete\n            \n        Returns:\n            Tuple of (success: bool, message: str)\n        \"\"\"\n        if not todo_id or not todo_id.strip():\n            return False, \"Error: Todo ID cannot be empty\"\n        \n        todo_id = todo_id.strip()\n        \n        if todo_id not in self._todos:\n            return False, f\"Error: Todo item with ID '{todo_id}' not found\"\n        \n        deleted_todo = self._todos.pop(todo_id)\n        return True, f\"Todo item '{deleted_todo.description}' deleted successfully\"\n    \n    def get_todo_count(self) -> int:\n        \"\"\"Get the total number of todo items.\"\"\"\n        return len(self._todos)\n    \n    def get_todos_by_id_prefix(self, prefix: str) -> List[TodoItem]:\n        \"\"\"\n        Get todos that match an ID prefix (for user convenience).\n        \n        Args:\n            prefix: The ID prefix to search for\n            \n        Returns:\n            List of matching todo items\n        \"\"\"\n        return [todo for todo in self._todos.values() if todo.id.startswith(prefix)]\n\n\nclass TodoApp:\n    \"\"\"Command-line interface for the todo list application.\"\"\"\n    \n    def __init__(self) -> None:\n        \"\"\"Initialize the todo application.\"\"\"\n        self.todo_manager = TodoManager()\n        self.running = True\n    \n    def display_menu(self) -> None:\n        \"\"\"Display the main menu options.\"\"\"\n        print(\"\\n\" + \"=\"*50)\n        print(\"           SIMPLE TODO LIST APP\")\n        print(\"=\"*50)\n        print(\"1. Add Todo Item\")\n        print(\"2. List All Todos\")\n        print(\"3. Delete Todo Item\")\n        print(\"4. Quit\")\n        print(\"-\"*50)\n    \n    def get_user_input(self, prompt: str, allow_empty: bool = False) -> str:\n        \"\"\"\n        Get validated user input.\n        \n        Args:\n            prompt: The prompt to display to user\n            allow_empty: Whether to allow empty input\n            \n        Returns:\n            The user's input string\n        \"\"\"\n        while True:\n            try:\n                user_input = input(prompt).strip()\n                if not allow_empty and not user_input:\n                    print(\"Error: Input cannot be empty. Please try again.\")\n                    continue\n                return user_input\n            except (EOFError, KeyboardInterrupt):\n                print(\"\\n\\nGoodbye!\")\n                self.running = False\n                return \"\"\n    \n    def handle_add_todo(self) -> None:\n        \"\"\"Handle adding a new todo item.\"\"\"\n        print(\"\\n--- Add New Todo ---\")\n        description = self.get_user_input(\"Enter todo description: \")\n        \n        if not self.running:  # User interrupted\n            return\n        \n        success, message = self.todo_manager.add_todo(description)\n        \n        if success:\n            print(f\"\u2713 {message}\")\n        else:\n            print(f\"\u2717 {message}\")\n    \n    def handle_list_todos(self) -> None:\n        \"\"\"Handle listing all todo items.\"\"\"\n        print(\"\\n--- Your Todo List ---\")\n        success, message = self.todo_manager.list_todos()\n        print(message)\n    \n    def handle_delete_todo(self) -> None:\n        \"\"\"Handle deleting a todo item.\"\"\"\n        print(\"\\n--- Delete Todo ---\")\n        \n        # First show current todos if any exist\n        if self.todo_manager.get_todo_count() == 0:\n            print(\"No todo items to delete. Your list is empty!\")\n            return\n        \n        # Show current todos for reference\n        _, todo_list = self.todo_manager.list_todos()\n        print(todo_list)\n        \n        todo_id = self.get_user_input(\"Enter todo ID to delete: \")\n        \n        if not self.running:  # User interrupted\n            return\n        \n        # Try to find todo by exact ID or prefix match\n        if todo_id not in [todo.id for todo in self.todo_manager._todos.values()]:\n            # Try prefix matching\n            matches = self.todo_manager.get_todos_by_id_prefix(todo_id)\n            if len(matches) == 1:\n                todo_id = matches[0].id\n                print(f\"Found match: {matches[0].description}\")\n            elif len(matches) > 1:\n                print(f\"Multiple matches found for '{todo_id}':\")\n                for match in matches:\n                    print(f\"  {match}\")\n                print(\"Please be more specific with the ID.\")\n                return\n        \n        success, message = self.todo_manager.delete_todo(todo_id)\n        \n        if success:\n            print(f\"\u2713 {message}\")\n        else:\n            print(f\"\u2717 {message}\")\n    \n    def handle_menu_selection(self, choice: str) -> None:\n        \"\"\"\n        Handle user menu selection.\n        \n        Args:\n            choice: The user's menu choice\n        \"\"\"\n        if choice == \"1\":\n            self.handle_add_todo()\n        elif choice == \"2\":\n            self.handle_list_todos()\n        elif choice == \"3\":\n            self.handle_delete_todo()\n        elif choice == \"4\":\n            print(\"\\nThank you for using Simple Todo List App!\")\n            print(\"Have a productive day! \ud83d\udc4b\")\n            self.running = False\n        else:\n            print(f\"\u2717 Error: Invalid choice '{choice}'. Please select 1, 2, 3, or 4.\")\n    \n    def run(self) -> None:\n        \"\"\"Main application loop.\"\"\"\n        print(\"Welcome to Simple Todo List App!\")\n        print(\"Manage your tasks efficiently from the command line.\")\n        \n        while self.running:\n            try:\n                self.display_menu()\n                \n                # Show current todo count\n                count = self.todo_manager.get_todo_count()\n                print(f\"Current todos: {count}\")\n                \n                choice = self.get_user_input(\"Select an option (1-4): \")\n                \n                if not self.running:  # User interrupted\n                    break\n                \n                self.handle_menu_selection(choice)\n                \n                # Pause for user to read output\n                if self.running and choice in [\"1\", \"2\", \"3\"]:\n                    input(\"\\nPress Enter to continue...\")\n                    \n            except KeyboardInterrupt:\n                print(\"\\n\\nGoodbye!\")\n                break\n            except Exception as e:\n                print(f\"\\n\u2717 An unexpected error occurred: {e}\")\n                print(\"Please try again.\")\n\n\ndef main() -> None:\n    \"\"\"Main entry point for the application.\"\"\"\n    app = TodoApp()\n    app.run()\n\n\nif __name__ == \"__main__\":\n    main()",
      "language": "python",
      "metadata": {
        "extracted_from": "code_block",
        "index": 0,
        "step_id": "implement",
        "agent": "Developer"
      },
      "created_at": "2026-02-14T00:49:39.905060"
    }
  ],
  "created_at": "2026-02-14T00:49:39.904550",
  "metadata": {},
  "stats": {
    "count": 1,
    "total_size_bytes": 9379,
    "total_lines": 286
  }
}